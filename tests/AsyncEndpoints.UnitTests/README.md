# AsyncEndpoints Unit Tests

This project is set up with xUnit, AutoFixture, and AutoMoq to simplify future unit test creation for the AsyncEndpoints library.

## Setup

The test project is configured with:
- **xUnit** - Testing framework
- **AutoFixture** - Automated object creation
- **AutoMoq** - Automatic mock creation for dependencies
- **AutoData** - Attribute for automatic parameter generation

## Ready for Use

AutoFixture and AutoMoq are now configured and ready for writing unit tests. When you create tests in the future, you should primarily use:

### AutoMoqData Attribute for Automatic Dependency Injection (Preferred)

```csharp
[Theory, AutoMoqData]
public void MyTest_WithAutoGeneratedParameters(
    string testData,
    Mock<IService> mockService,
    Job job)  // AutoFixture automatically creates instances
{
    // AutoFixture automatically creates instances of string, Mock<IService>, and Job
    // The Mock<IService> is automatically registered with the container
    var sut = new SystemUnderTest(mockService.Object);

    // Your test logic here
    sut.DoSomething(testData, job);

    // Verify behavior
    mockService.Verify(x => x.MethodCalled(testData), Times.Once);
}
```

### Manual Fixture Creation (Use ONLY when absolutely necessary)

In rare cases where you cannot achieve the desired configuration through method parameters, you can create a fixture manually. However, this approach should be avoided when possible in favor of adding parameters to your test method:

```csharp
[Fact]
public void MyTest_WithCustomizedFixture()
{
    // Only use manual fixture creation when method parameters are insufficient
    var fixture = new Fixture().Customize(new AutoMoqCustomization());
    
    // Customize specific behaviors
    var specificObject = fixture.Create<MyClass>();
    
    // Your test logic here
}
```

## Important Mocking Considerations

### Extension Methods Cannot Be Mocked Directly

One common issue you may encounter is that extension methods cannot be mocked directly. For example:

- `CreateAsyncScope()` is an extension method from `Microsoft.Extensions.DependencyInjection`
- It internally calls `CreateScope()` on the `IServiceScopeFactory`
- Instead of mocking `CreateAsyncScope()`, you must mock the underlying `CreateScope()` method

**Example:**

In the source code:
```csharp
await using var scope = _serviceScopeFactory.CreateAsyncScope();
```

In the unit test:
```csharp
mockServiceScopeFactory
    .Setup(x => x.CreateScope())  // Mock the underlying method, not the extension
    .Returns(mockServiceScope.Object);
```

**Real-world example from AsyncEndpoints:**

In `JobProducerService.cs` and `JobConsumerService.cs`, we use `CreateAsyncScope()` but in the corresponding tests (`JobProducerServiceTests.cs` and `JobConsumerServiceTests.cs`), we mock `CreateScope()` instead.

### Another Common Extension Method Issue: GetRequiredService vs GetService

Similar to the `CreateAsyncScope` issue, `GetRequiredService<T>()` is also an extension method that cannot be mocked directly. Instead:

- `GetRequiredService<T>()` internally calls `GetService(typeof(T))` and throws an exception if the service is not found
- Mock the underlying `GetService(Type)` method instead

**Example from the tests:**

In the source code:
```csharp
var jobClaimingService = scope.ServiceProvider.GetRequiredService<IJobClaimingService>();
```

In the unit test:
```csharp
mockServiceScope
    .Setup(x => x.ServiceProvider.GetService(typeof(IJobClaimingService)))
    .Returns(mockJobClaimingService.Object);
```

**Real-world example from AsyncEndpoints:**

In `JobProducerServiceTests.cs` and `JobConsumerServiceTests.cs`, we mock `GetService()` instead of `GetRequiredService()`.

### Other Common Extension Method Issues

Similar patterns occur with other extension methods throughout the codebase. When you encounter mocking issues:

1. Check if the method you're trying to mock is an extension method
2. Research the underlying methods that the extension method calls
3. Mock those underlying methods instead
4. Look for similar patterns in existing tests to understand the correct mocking approach

## Best Practices

1. **PREFER `[Theory, AutoMoqData]`** for parameterized tests with automatic parameter generation
2. Add required objects as method parameters rather than manually creating them
3. Use `[Fact]` for simple tests that don't need automatic parameter generation
4. Leverage AutoFixture for creating complex object graphs through method parameters
5. Use AutoMoq for automatic mocking of dependencies
6. Only use manual fixture creation when method parameters are insufficient for your scenario
7. Create reusable test attributes for common test patterns
8. Remember to mock underlying methods instead of extension methods

## Moq Parameter Setup with Optional Parameters

When mocking methods that have optional parameters (parameters with default values), you must specify all parameters in the setup if you want to control their values. This is a limitation in Moq.

**Example of correct mocking:**
```csharp
// When the actual method signature is:
// string Serialize<T>(T value, JsonSerializerOptions? options = null)

// You should mock all parameters:
mockSerializer
    .Setup(x => x.Serialize(It.IsAny<object>(), It.IsAny<JsonSerializerOptions>()))
    .Returns(expectedResult);

// Or for the non-generic overload:
// string Serialize(object value, Type type, JsonSerializerOptions? options = null)
mockSerializer
    .Setup(x => x.Serialize(It.IsAny<object>(), It.IsAny<Type>(), It.IsAny<JsonSerializerOptions>()))
    .Returns(expectedResult);
```

## Unit Testing Standards

### Test Structure
- **Follow the Arrange-Act-Assert (AAA) pattern**:
  - **Arrange**: Set up test data, dependencies, and mocks
  - **Act**: Execute the operation being tested
  - **Assert**: Verify the expected outcomes

### Test Naming Convention
- Use the format: `MethodName_Condition_ExpectedOutcome`
- Example: `SubmitJob_CreatesNewJob_WhenJobDoesNotExist`

### Test Documentation
- Include XML documentation comments for each test method
- Format: `/// <summary>Verifies that [specific behavior] [expected outcome].</summary>`
- Example:
```csharp
/// <summary>
/// Verifies that when a job ID is provided in the request headers and the job already exists, 
/// the JobManager returns the existing job instead of creating a new one.
/// This ensures idempotent behavior for job submissions with duplicate IDs.
/// </summary>
```

### Test Scope
- **Single Responsibility**: Each test should verify one specific behavior or scenario
- **Independent**: Tests should not depend on each other or shared state
- **Deterministic**: Tests should produce the same results every time they run

### Assertion Guidelines
- Group related assertions logically within a test, but consider splitting if testing different scenarios
- Use specific assertions with descriptive messages when needed
- Verify both success and failure scenarios
- Test edge cases and error conditions

### Mocking Standards
- Use AutoFixture and AutoMoq for automatic dependency injection when possible
- Mock the actual underlying methods, not extension methods
- Set up return values and verify interactions appropriately
- Avoid excessive mocking - aim for focused unit tests

### Performance
- Keep tests fast and efficient for good development workflow
- Use in-memory implementations when possible instead of external dependencies

### Maintainability
- Write clear, readable test code that serves as documentation
- Update test documentation when test behavior changes
- Keep tests in sync with source code changes